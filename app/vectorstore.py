# app/vectorstore.py

import logging
from typing import Optional
from pymilvus import Collection, CollectionSchema, DataType, FieldSchema, connections, utility, Function, FunctionType
from langchain_milvus import Milvus
from langchain_huggingface import HuggingFaceEmbeddings

logger = logging.getLogger(__name__)

# You can parameterize these via env vars later
MILVUS_HOST = "localhost"
MILVUS_PORT = "19530"
COLLECTION_NAME = "financial_docs"

# BGE-large-en produces 1024-dimensional embeddings
EMBEDDING_DIM = 1024

# Instantiate embeddings once (local BGE-large)
embeddings = HuggingFaceEmbeddings(model_name="BAAI/bge-large-en")


def get_milvus_collection() -> Collection:
    """Get the Milvus collection object for direct operations."""
    connections.connect(
        alias="default",
        host=MILVUS_HOST,
        port=MILVUS_PORT,
    )
    return Collection(name=COLLECTION_NAME, using="default")


def insert_documents_with_hybrid(docs: list) -> int:
    """
    Insert documents with dense vectors. Milvus automatically generates sparse vectors from text.
    
    Args:
        docs: List of LangChain Document objects
    
    Returns:
        Number of documents inserted
    """
    if not docs:
        logger.warning("No documents to insert")
        return 0
    
    logger.info(f"Starting hybrid insertion for {len(docs)} documents")
    
    try:
        # Get collection
        collection = get_milvus_collection()
        
        # Prepare data for insertion
        texts = [doc.page_content for doc in docs]
        logger.debug(f"Extracted {len(texts)} text chunks")
        
        # Generate dense embeddings only
        # Sparse vectors will be auto-generated by Milvus BM25 function from text field
        logger.debug("Generating dense embeddings...")
        dense_vectors = embeddings.embed_documents(texts)
        logger.debug(f"Generated {len(dense_vectors)} dense vectors")
        logger.debug("Sparse vectors will be auto-generated by Milvus from text field")
    except Exception as e:
        logger.error(f"Error during embedding generation: {str(e)}", exc_info=True)
        raise
    
    # Prepare entities
    # Note: Do NOT include sparse_vector - Milvus generates it automatically from text
    entities = []
    for i, doc in enumerate(docs):
        md = doc.metadata or {}
        entity = {
            "vector": dense_vectors[i],
            "text": doc.page_content,  # Milvus BM25 function uses this to generate sparse_vector
            "source": md.get("source", ""),
            "file_name": md.get("file_name", ""),
            "chunk_id": md.get("chunk_id", ""),
            "page_start": int(md.get("page_start", 0)),
            "page_end": int(md.get("page_end", 0)),
            "chunk_index": int(md.get("chunk_index", 0)),
            "section_type": md.get("section_type", "text"),
        }
        
        # Note: section_title is handled by dynamic fields if present
        # Only add if it exists and is not None (dynamic field)
        if md.get("section_title"):
            entity["section_title"] = md["section_title"]
        
        entities.append(entity)
    
    logger.debug(f"Prepared {len(entities)} entities for insertion")
    
    try:
        # Insert into collection
        logger.debug("Inserting entities into Milvus collection...")
        insert_result = collection.insert(entities)
        logger.debug(f"Insert result: {insert_result}")
        
        logger.debug("Flushing collection...")
        collection.flush()
        
        logger.info(f"Successfully inserted {len(entities)} documents with hybrid vectors")
        return len(entities)
    except Exception as e:
        logger.error(f"Error during Milvus insertion: {str(e)}", exc_info=True)
        logger.error(f"Sample entity structure: {entities[0] if entities else 'No entities'}")
        raise


def create_collection_schema() -> CollectionSchema:
    """
    Define the explicit schema for the Milvus collection with hybrid search support.
    Uses built-in BM25 function to automatically generate sparse vectors from text.
    """
    fields = [
        # Primary key - auto-generated
        FieldSchema(
            name="pk",
            dtype=DataType.VARCHAR,
            is_primary=True,
            auto_id=True,
            max_length=100,
        ),
        # Dense vector embeddings (semantic)
        FieldSchema(
            name="vector",
            dtype=DataType.FLOAT_VECTOR,
            dim=EMBEDDING_DIM,
        ),
        # Text content - source for BM25 sparse vectors
        FieldSchema(
            name="text",
            dtype=DataType.VARCHAR,
            max_length=65535,  # Max text length
            enable_analyzer=True,  # Enable text analysis for BM25
            enable_match=True,
        ),

        # Metadata fields
        FieldSchema(
            name="source",
            dtype=DataType.VARCHAR,
            max_length=512,
        ),
        FieldSchema(
            name="file_name",
            dtype=DataType.VARCHAR,
            max_length=512,
        ),
        FieldSchema(
            name="chunk_id",
            dtype=DataType.VARCHAR,
            max_length=100,
        ),
        FieldSchema(
            name="page_start",
            dtype=DataType.INT64,
        ),
        FieldSchema(
            name="page_end",
            dtype=DataType.INT64,
        ),
        FieldSchema(
            name="chunk_index",
            dtype=DataType.INT64,
        ),
        FieldSchema(
            name="section_type",
            dtype=DataType.VARCHAR,
            max_length=50,
        ),
    ]
    
    schema = CollectionSchema(
        fields=fields,
        description="Financial documents with embeddings for RAG",
        enable_dynamic_field=True,  # Allow additional fields if needed
    )
    
    # Define BM25 function to auto-generate sparse vectors from text field
    bm25_function = Function(
        name="bm25",
        function_type=FunctionType.BM25,
        input_field_names=["text"],  # Source field
        output_field_names=["sparse_vector"],  # Auto-generated field
    )
    
    # Add the BM25 function to schema
    schema.add_function(bm25_function)
    
    return schema


def ensure_collection_exists() -> None:
    """
    Ensure the collection exists with the proper schema.
    If it doesn't exist, create it. If it exists, verify schema compatibility.
    """
    # Connect to Milvus
    connections.connect(
        alias="default",
        host=MILVUS_HOST,
        port=MILVUS_PORT,
    )
    
    # Check if collection exists
    if utility.has_collection(COLLECTION_NAME):
        print(f"Collection '{COLLECTION_NAME}' already exists.")
        return
    
    # Create collection with schema
    schema = create_collection_schema()
    collection = Collection(
        name=COLLECTION_NAME,
        schema=schema,
        using="default",
    )
    
    # Create index for dense vector field
    dense_index_params = {
        "metric_type": "COSINE",
        "index_type": "IVF_FLAT",
        "params": {"nlist": 1024},
    }
    
    collection.create_index(
        field_name="vector",
        index_params=dense_index_params,
    )
    
    # Create index for sparse vector field
    # Note: Sparse vectors MUST use IP (Inner Product) metric
    # BM25 is used for encoding/tokenization, not as a distance metric
    sparse_index_params = {
        "index_type": "SPARSE_INVERTED_INDEX",
        "metric_type": "IP",  # Only IP is supported for sparse vectors
    }
    
    collection.create_index(
        field_name="sparse_vector",
        index_params=sparse_index_params,
    )
    
    logger.info(f"Collection '{COLLECTION_NAME}' created with hybrid search support (dense + built-in BM25)")
    print(f"Collection '{COLLECTION_NAME}' created successfully with built-in BM25 function.")


def get_vectorstore() -> Milvus:
    """
    Creates (or returns) a Milvus-backed LangChain VectorStore.
    Ensures the collection exists with proper schema before returning.
    """
    # Ensure collection exists with proper schema
    ensure_collection_exists()
    
    vectorstore = Milvus(
        embedding_function=embeddings,
        collection_name=COLLECTION_NAME,
        connection_args={
            "host": MILVUS_HOST,
            "port": MILVUS_PORT,
        },
        # Search parameters
        search_params={
            "metric_type": "COSINE",
            "params": {"nprobe": 10},
        },
        # Specify which fields to return
        text_field="text",
        vector_field="vector",
        primary_field="pk",
        auto_id=True,  # Tell LangChain that primary key is auto-generated
    )
    
    return vectorstore
